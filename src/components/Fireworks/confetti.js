/**
 * Bundled by jsDelivr using Rollup v2.74.1 and Terser v5.15.1.
 * Original file: /npm/tsparticles-confetti@2.9.3/esm/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import { deepExtend as t, tsParticles as i } from "/npm/tsparticles-engine@2.9.3/+esm"; import { loadAngleUpdater as e } from "/npm/tsparticles-updater-angle@2.9.3/+esm"; import { loadBaseMover as a } from "/npm/tsparticles-move-base@2.9.3/+esm"; import { loadCardsShape as s } from "/npm/tsparticles-shape-cards@2.9.3/+esm"; import { loadCircleShape as o } from "/npm/tsparticles-shape-circle@2.9.3/+esm"; import { loadColorUpdater as r } from "/npm/tsparticles-updater-color@2.9.3/+esm"; import { loadEmittersPlugin as n } from "/npm/tsparticles-plugin-emitters@2.9.3/+esm"; import { loadHeartShape as p } from "/npm/tsparticles-shape-heart@2.9.3/+esm"; import { loadImageShape as l } from "/npm/tsparticles-shape-image@2.9.3/+esm"; import { loadLifeUpdater as c } from "/npm/tsparticles-updater-life@2.9.3/+esm"; import { loadMotionPlugin as d } from "/npm/tsparticles-plugin-motion@2.9.3/+esm"; import { loadOpacityUpdater as m } from "/npm/tsparticles-updater-opacity@2.9.3/+esm"; import { loadOutModesUpdater as u } from "/npm/tsparticles-updater-out-modes@2.9.3/+esm"; import { loadPolygonShape as f } from "/npm/tsparticles-shape-polygon@2.9.3/+esm"; import { loadRollUpdater as h } from "/npm/tsparticles-updater-roll@2.9.3/+esm"; import { loadSizeUpdater as y } from "/npm/tsparticles-updater-size@2.9.3/+esm"; import { loadSquareShape as v } from "/npm/tsparticles-shape-square@2.9.3/+esm"; import { loadStarShape as g } from "/npm/tsparticles-shape-star@2.9.3/+esm"; import { loadTextShape as w } from "/npm/tsparticles-shape-text@2.9.3/+esm"; import { loadTiltUpdater as x } from "/npm/tsparticles-updater-tilt@2.9.3/+esm"; import { loadWobbleUpdater as b } from "/npm/tsparticles-updater-wobble@2.9.3/+esm"; class z { constructor() { this.angle = 90, this.count = 50, this.spread = 45, this.startVelocity = 45, this.decay = .9, this.gravity = 1, this.drift = 0, this.ticks = 200, this.position = { x: 50, y: 50 }, this.colors = ["#26ccff", "#a25afd", "#ff5e7e", "#88ff5a", "#fcff42", "#ffa62d", "#ff36ff"], this.shapes = ["square", "circle"], this.scalar = 1, this.zIndex = 100, this.disableForReducedMotion = !0, this.shapeOptions = {} } get origin() { return { x: this.position.x / 100, y: this.position.y / 100 } } set origin(t) { this.position.x = 100 * t.x, this.position.y = 100 * t.y } get particleCount() { return this.count } set particleCount(t) { this.count = t } load(i) { var e, a; if (!i) return; void 0 !== i.angle && (this.angle = i.angle); const s = null !== (e = i.count) && void 0 !== e ? e : i.particleCount; void 0 !== s && (this.count = s), void 0 !== i.spread && (this.spread = i.spread), void 0 !== i.startVelocity && (this.startVelocity = i.startVelocity), void 0 !== i.decay && (this.decay = i.decay), void 0 !== i.gravity && (this.gravity = i.gravity), void 0 !== i.drift && (this.drift = i.drift), void 0 !== i.ticks && (this.ticks = i.ticks); const o = i.origin; o && !i.position && (i.position = { x: void 0 !== o.x ? 100 * o.x : void 0, y: void 0 !== o.y ? 100 * o.y : void 0 }); const r = i.position; r && (void 0 !== r.x && (this.position.x = r.x), void 0 !== r.y && (this.position.y = r.y)), void 0 !== i.colors && (i.colors instanceof Array ? this.colors = [...i.colors] : this.colors = i.colors); const n = i.shapeOptions; if (void 0 !== n) for (const i in n) { const e = n[i]; e && (this.shapeOptions[i] = t(null !== (a = this.shapeOptions[i]) && void 0 !== a ? a : {}, e)) } void 0 !== i.shapes && (i.shapes instanceof Array ? this.shapes = [...i.shapes] : this.shapes = i.shapes), void 0 !== i.scalar && (this.scalar = i.scalar), void 0 !== i.zIndex && (this.zIndex = i.zIndex), void 0 !== i.disableForReducedMotion && (this.disableForReducedMotion = i.disableForReducedMotion) } } let k = !1, I = !1; const M = new Map; async function V() { if (!k) { if (I) return new Promise((t => { const i = setInterval((() => { k && (clearInterval(i), t()) }), 100) })); I = !0, await a(i), await n(i), await d(i), await s(i), await o(i), await p(i), await l(i), await f(i), await v(i), await g(i), await w(i), await e(i), await r(i), await c(i), await m(i), await u(i), await h(i), await y(i), await x(i), await b(i), I = !1, k = !0 } } async function O(t) { const e = new z; let a; if (e.load(t.options), M.has(t.id) && (a = M.get(t.id), a && !a.destroyed)) { const t = a; if (t.addEmitter) return void t.addEmitter({ startCount: e.count, position: e.position, size: { width: 0, height: 0 }, rate: { delay: 0, quantity: 0 }, life: { duration: .1, count: 1 }, particles: { color: { value: e.colors }, shape: { type: e.shapes, options: e.shapeOptions }, size: { value: 5 * e.scalar }, life: { duration: { value: e.ticks / 60 } }, move: { angle: { value: e.spread, offset: 0 }, drift: { min: -e.drift, max: e.drift }, gravity: { acceleration: 9.81 * e.gravity }, speed: 3 * e.startVelocity, decay: 1 - e.decay, direction: -e.angle } } }) } const s = { fullScreen: { enable: !t.canvas, zIndex: e.zIndex }, fpsLimit: 120, particles: { number: { value: 0 }, color: { value: e.colors }, shape: { type: e.shapes, options: e.shapeOptions }, opacity: { value: { min: 0, max: 1 }, animation: { enable: !0, speed: .5, startValue: "max", destroy: "min" } }, size: { value: 5 * e.scalar }, links: { enable: !1 }, life: { duration: { sync: !0, value: e.ticks / 60 }, count: 1 }, move: { angle: { value: e.spread, offset: 0 }, drift: { min: -e.drift, max: e.drift }, enable: !0, gravity: { enable: !0, acceleration: 9.81 * e.gravity }, speed: 3 * e.startVelocity, decay: 1 - e.decay, direction: -e.angle, random: !0, straight: !1, outModes: { default: "none", bottom: "destroy" } }, rotate: { value: { min: 0, max: 360 }, direction: "random", animation: { enable: !0, speed: 60 } }, tilt: { direction: "random", enable: !0, value: { min: 0, max: 360 }, animation: { enable: !0, speed: 60 } }, roll: { darken: { enable: !0, value: 25 }, enable: !0, speed: { min: 15, max: 25 } }, wobble: { distance: 30, enable: !0, speed: { min: -15, max: 15 } } }, detectRetina: !0, motion: { disable: e.disableForReducedMotion }, emitters: { name: "confetti", startCount: e.count, position: e.position, size: { width: 0, height: 0 }, rate: { delay: 0, quantity: 0 }, life: { duration: .1, count: 1 } } }; return t.id ? a = await i.load(t.id, s) : t.canvas && (a = await i.set(t.id, t.canvas, s)), M.set(t.id, a), a } async function R(t, i) { let e, a; return await V(), "string" == typeof t ? (a = t, e = null != i ? i : {}) : (a = "confetti", e = t), O({ id: a, options: e }) } R.create = async (t, i) => { if (!t) return R; await V(); const e = t.getAttribute("id") || "confetti"; return t.setAttribute("id", e), async (a, s) => { let o, r; return "string" == typeof a ? (r = a, o = null != s ? s : i) : (r = e, o = a), O({ id: r, canvas: t, options: o }) } }; export { R as confetti }; export default null;
 //# sourceMappingURL=/sm/28d61c7b43d7ed286bb5ce221a22ba957408767de446dd359e5909155a3e41ab.map